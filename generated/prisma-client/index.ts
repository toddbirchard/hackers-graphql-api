// Code generated by Prisma (prisma@1.28.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  author: (where?: authorWhereInput) => Promise<boolean>;
  epicMeta: (where?: epicMetaWhereInput) => Promise<boolean>;
  jiraIssue: (where?: jiraIssueWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  author: (where: authorWhereUniqueInput) => authorPromise;
  authors: (
    args?: {
      where?: authorWhereInput;
      orderBy?: authorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<author>;
  authorsConnection: (
    args?: {
      where?: authorWhereInput;
      orderBy?: authorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => authorConnectionPromise;
  epicMeta: (where: epicMetaWhereUniqueInput) => epicMetaPromise;
  epicMetas: (
    args?: {
      where?: epicMetaWhereInput;
      orderBy?: epicMetaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<epicMeta>;
  epicMetasConnection: (
    args?: {
      where?: epicMetaWhereInput;
      orderBy?: epicMetaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => epicMetaConnectionPromise;
  jiraIssue: (where: jiraIssueWhereUniqueInput) => jiraIssuePromise;
  jiraIssues: (
    args?: {
      where?: jiraIssueWhereInput;
      orderBy?: jiraIssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<jiraIssue>;
  jiraIssuesConnection: (
    args?: {
      where?: jiraIssueWhereInput;
      orderBy?: jiraIssueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => jiraIssueConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createauthor: (data: authorCreateInput) => authorPromise;
  updateauthor: (
    args: { data: authorUpdateInput; where: authorWhereUniqueInput }
  ) => authorPromise;
  updateManyauthors: (
    args: { data: authorUpdateManyMutationInput; where?: authorWhereInput }
  ) => BatchPayloadPromise;
  upsertauthor: (
    args: {
      where: authorWhereUniqueInput;
      create: authorCreateInput;
      update: authorUpdateInput;
    }
  ) => authorPromise;
  deleteauthor: (where: authorWhereUniqueInput) => authorPromise;
  deleteManyauthors: (where?: authorWhereInput) => BatchPayloadPromise;
  createepicMeta: (data: epicMetaCreateInput) => epicMetaPromise;
  updateepicMeta: (
    args: { data: epicMetaUpdateInput; where: epicMetaWhereUniqueInput }
  ) => epicMetaPromise;
  updateManyepicMetas: (
    args: { data: epicMetaUpdateManyMutationInput; where?: epicMetaWhereInput }
  ) => BatchPayloadPromise;
  upsertepicMeta: (
    args: {
      where: epicMetaWhereUniqueInput;
      create: epicMetaCreateInput;
      update: epicMetaUpdateInput;
    }
  ) => epicMetaPromise;
  deleteepicMeta: (where: epicMetaWhereUniqueInput) => epicMetaPromise;
  deleteManyepicMetas: (where?: epicMetaWhereInput) => BatchPayloadPromise;
  createjiraIssue: (data: jiraIssueCreateInput) => jiraIssuePromise;
  updatejiraIssue: (
    args: { data: jiraIssueUpdateInput; where: jiraIssueWhereUniqueInput }
  ) => jiraIssuePromise;
  updateManyjiraIssues: (
    args: {
      data: jiraIssueUpdateManyMutationInput;
      where?: jiraIssueWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertjiraIssue: (
    args: {
      where: jiraIssueWhereUniqueInput;
      create: jiraIssueCreateInput;
      update: jiraIssueUpdateInput;
    }
  ) => jiraIssuePromise;
  deletejiraIssue: (where: jiraIssueWhereUniqueInput) => jiraIssuePromise;
  deleteManyjiraIssues: (where?: jiraIssueWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  author: (
    where?: authorSubscriptionWhereInput
  ) => authorSubscriptionPayloadSubscription;
  epicMeta: (
    where?: epicMetaSubscriptionWhereInput
  ) => epicMetaSubscriptionPayloadSubscription;
  jiraIssue: (
    where?: jiraIssueSubscriptionWhereInput
  ) => jiraIssueSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type authorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "email_ASC"
  | "email_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "website_ASC"
  | "website_DESC"
  | "location_ASC"
  | "location_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "title_ASC"
  | "title_DESC"
  | "linkedin_ASC"
  | "linkedin_DESC"
  | "vimeo_ASC"
  | "vimeo_DESC"
  | "quora_ASC"
  | "quora_DESC"
  | "medium_ASC"
  | "medium_DESC"
  | "github_ASC"
  | "github_DESC"
  | "meetup_ASC"
  | "meetup_DESC"
  | "pocket_ASC"
  | "pocket_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type epicMetaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "color_ASC"
  | "color_DESC"
  | "name_ASC"
  | "name_DESC";

export type jiraIssueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "assignee_name_ASC"
  | "assignee_name_DESC"
  | "assignee_url_ASC"
  | "assignee_url_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "status_ASC"
  | "status_DESC"
  | "priority_name_ASC"
  | "priority_name_DESC"
  | "priority_url_ASC"
  | "priority_url_DESC"
  | "priority_rank_ASC"
  | "priority_rank_DESC"
  | "updated_ASC"
  | "updated_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "epic_color_ASC"
  | "epic_color_DESC"
  | "epic_name_ASC"
  | "epic_name_DESC"
  | "project_ASC"
  | "project_DESC"
  | "issuetype_name_ASC"
  | "issuetype_name_DESC"
  | "issuetype_url_ASC"
  | "issuetype_url_DESC";

export interface epicMetaUpdateInput {
  color?: String;
  name?: String;
}

export interface epicMetaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: epicMetaWhereInput[] | epicMetaWhereInput;
  OR?: epicMetaWhereInput[] | epicMetaWhereInput;
  NOT?: epicMetaWhereInput[] | epicMetaWhereInput;
}

export type authorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface epicMetaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: epicMetaWhereInput;
  AND?: epicMetaSubscriptionWhereInput[] | epicMetaSubscriptionWhereInput;
  OR?: epicMetaSubscriptionWhereInput[] | epicMetaSubscriptionWhereInput;
  NOT?: epicMetaSubscriptionWhereInput[] | epicMetaSubscriptionWhereInput;
}

export interface authorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  website?: String;
  website_not?: String;
  website_in?: String[] | String;
  website_not_in?: String[] | String;
  website_lt?: String;
  website_lte?: String;
  website_gt?: String;
  website_gte?: String;
  website_contains?: String;
  website_not_contains?: String;
  website_starts_with?: String;
  website_not_starts_with?: String;
  website_ends_with?: String;
  website_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  facebook?: String;
  facebook_not?: String;
  facebook_in?: String[] | String;
  facebook_not_in?: String[] | String;
  facebook_lt?: String;
  facebook_lte?: String;
  facebook_gt?: String;
  facebook_gte?: String;
  facebook_contains?: String;
  facebook_not_contains?: String;
  facebook_starts_with?: String;
  facebook_not_starts_with?: String;
  facebook_ends_with?: String;
  facebook_not_ends_with?: String;
  twitter?: String;
  twitter_not?: String;
  twitter_in?: String[] | String;
  twitter_not_in?: String[] | String;
  twitter_lt?: String;
  twitter_lte?: String;
  twitter_gt?: String;
  twitter_gte?: String;
  twitter_contains?: String;
  twitter_not_contains?: String;
  twitter_starts_with?: String;
  twitter_not_starts_with?: String;
  twitter_ends_with?: String;
  twitter_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  linkedin?: String;
  linkedin_not?: String;
  linkedin_in?: String[] | String;
  linkedin_not_in?: String[] | String;
  linkedin_lt?: String;
  linkedin_lte?: String;
  linkedin_gt?: String;
  linkedin_gte?: String;
  linkedin_contains?: String;
  linkedin_not_contains?: String;
  linkedin_starts_with?: String;
  linkedin_not_starts_with?: String;
  linkedin_ends_with?: String;
  linkedin_not_ends_with?: String;
  vimeo?: String;
  vimeo_not?: String;
  vimeo_in?: String[] | String;
  vimeo_not_in?: String[] | String;
  vimeo_lt?: String;
  vimeo_lte?: String;
  vimeo_gt?: String;
  vimeo_gte?: String;
  vimeo_contains?: String;
  vimeo_not_contains?: String;
  vimeo_starts_with?: String;
  vimeo_not_starts_with?: String;
  vimeo_ends_with?: String;
  vimeo_not_ends_with?: String;
  quora?: String;
  quora_not?: String;
  quora_in?: String[] | String;
  quora_not_in?: String[] | String;
  quora_lt?: String;
  quora_lte?: String;
  quora_gt?: String;
  quora_gte?: String;
  quora_contains?: String;
  quora_not_contains?: String;
  quora_starts_with?: String;
  quora_not_starts_with?: String;
  quora_ends_with?: String;
  quora_not_ends_with?: String;
  medium?: String;
  medium_not?: String;
  medium_in?: String[] | String;
  medium_not_in?: String[] | String;
  medium_lt?: String;
  medium_lte?: String;
  medium_gt?: String;
  medium_gte?: String;
  medium_contains?: String;
  medium_not_contains?: String;
  medium_starts_with?: String;
  medium_not_starts_with?: String;
  medium_ends_with?: String;
  medium_not_ends_with?: String;
  github?: String;
  github_not?: String;
  github_in?: String[] | String;
  github_not_in?: String[] | String;
  github_lt?: String;
  github_lte?: String;
  github_gt?: String;
  github_gte?: String;
  github_contains?: String;
  github_not_contains?: String;
  github_starts_with?: String;
  github_not_starts_with?: String;
  github_ends_with?: String;
  github_not_ends_with?: String;
  meetup?: String;
  meetup_not?: String;
  meetup_in?: String[] | String;
  meetup_not_in?: String[] | String;
  meetup_lt?: String;
  meetup_lte?: String;
  meetup_gt?: String;
  meetup_gte?: String;
  meetup_contains?: String;
  meetup_not_contains?: String;
  meetup_starts_with?: String;
  meetup_not_starts_with?: String;
  meetup_ends_with?: String;
  meetup_not_ends_with?: String;
  pocket?: String;
  pocket_not?: String;
  pocket_in?: String[] | String;
  pocket_not_in?: String[] | String;
  pocket_lt?: String;
  pocket_lte?: String;
  pocket_gt?: String;
  pocket_gte?: String;
  pocket_contains?: String;
  pocket_not_contains?: String;
  pocket_starts_with?: String;
  pocket_not_starts_with?: String;
  pocket_ends_with?: String;
  pocket_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: authorWhereInput[] | authorWhereInput;
  OR?: authorWhereInput[] | authorWhereInput;
  NOT?: authorWhereInput[] | authorWhereInput;
}

export interface authorUpdateManyMutationInput {
  name?: String;
  slug?: String;
  email?: String;
  bio?: String;
  website?: String;
  location?: String;
  facebook?: String;
  twitter?: String;
  title?: String;
  linkedin?: String;
  vimeo?: String;
  quora?: String;
  medium?: String;
  github?: String;
  meetup?: String;
  pocket?: String;
}

export interface jiraIssueUpdateManyMutationInput {
  key?: String;
  assignee_name?: String;
  assignee_url?: String;
  summary?: String;
  status?: String;
  priority_name?: String;
  priority_url?: String;
  priority_rank?: Int;
  updated?: DateTimeInput;
  epic_color?: String;
  epic_name?: String;
  project?: String;
  issuetype_name?: String;
  issuetype_url?: String;
}

export interface authorUpdateInput {
  name?: String;
  slug?: String;
  email?: String;
  bio?: String;
  website?: String;
  location?: String;
  facebook?: String;
  twitter?: String;
  title?: String;
  linkedin?: String;
  vimeo?: String;
  quora?: String;
  medium?: String;
  github?: String;
  meetup?: String;
  pocket?: String;
}

export interface jiraIssueCreateInput {
  key: String;
  assignee_name?: String;
  assignee_url?: String;
  summary?: String;
  status: String;
  priority_name?: String;
  priority_url?: String;
  priority_rank?: Int;
  updated?: DateTimeInput;
  epic_color?: String;
  epic_name?: String;
  project: String;
  issuetype_name?: String;
  issuetype_url?: String;
}

export interface jiraIssueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: jiraIssueWhereInput;
  AND?: jiraIssueSubscriptionWhereInput[] | jiraIssueSubscriptionWhereInput;
  OR?: jiraIssueSubscriptionWhereInput[] | jiraIssueSubscriptionWhereInput;
  NOT?: jiraIssueSubscriptionWhereInput[] | jiraIssueSubscriptionWhereInput;
}

export interface jiraIssueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  assignee_name?: String;
  assignee_name_not?: String;
  assignee_name_in?: String[] | String;
  assignee_name_not_in?: String[] | String;
  assignee_name_lt?: String;
  assignee_name_lte?: String;
  assignee_name_gt?: String;
  assignee_name_gte?: String;
  assignee_name_contains?: String;
  assignee_name_not_contains?: String;
  assignee_name_starts_with?: String;
  assignee_name_not_starts_with?: String;
  assignee_name_ends_with?: String;
  assignee_name_not_ends_with?: String;
  assignee_url?: String;
  assignee_url_not?: String;
  assignee_url_in?: String[] | String;
  assignee_url_not_in?: String[] | String;
  assignee_url_lt?: String;
  assignee_url_lte?: String;
  assignee_url_gt?: String;
  assignee_url_gte?: String;
  assignee_url_contains?: String;
  assignee_url_not_contains?: String;
  assignee_url_starts_with?: String;
  assignee_url_not_starts_with?: String;
  assignee_url_ends_with?: String;
  assignee_url_not_ends_with?: String;
  summary?: String;
  summary_not?: String;
  summary_in?: String[] | String;
  summary_not_in?: String[] | String;
  summary_lt?: String;
  summary_lte?: String;
  summary_gt?: String;
  summary_gte?: String;
  summary_contains?: String;
  summary_not_contains?: String;
  summary_starts_with?: String;
  summary_not_starts_with?: String;
  summary_ends_with?: String;
  summary_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  priority_name?: String;
  priority_name_not?: String;
  priority_name_in?: String[] | String;
  priority_name_not_in?: String[] | String;
  priority_name_lt?: String;
  priority_name_lte?: String;
  priority_name_gt?: String;
  priority_name_gte?: String;
  priority_name_contains?: String;
  priority_name_not_contains?: String;
  priority_name_starts_with?: String;
  priority_name_not_starts_with?: String;
  priority_name_ends_with?: String;
  priority_name_not_ends_with?: String;
  priority_url?: String;
  priority_url_not?: String;
  priority_url_in?: String[] | String;
  priority_url_not_in?: String[] | String;
  priority_url_lt?: String;
  priority_url_lte?: String;
  priority_url_gt?: String;
  priority_url_gte?: String;
  priority_url_contains?: String;
  priority_url_not_contains?: String;
  priority_url_starts_with?: String;
  priority_url_not_starts_with?: String;
  priority_url_ends_with?: String;
  priority_url_not_ends_with?: String;
  priority_rank?: Int;
  priority_rank_not?: Int;
  priority_rank_in?: Int[] | Int;
  priority_rank_not_in?: Int[] | Int;
  priority_rank_lt?: Int;
  priority_rank_lte?: Int;
  priority_rank_gt?: Int;
  priority_rank_gte?: Int;
  updated?: DateTimeInput;
  updated_not?: DateTimeInput;
  updated_in?: DateTimeInput[] | DateTimeInput;
  updated_not_in?: DateTimeInput[] | DateTimeInput;
  updated_lt?: DateTimeInput;
  updated_lte?: DateTimeInput;
  updated_gt?: DateTimeInput;
  updated_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  epic_color?: String;
  epic_color_not?: String;
  epic_color_in?: String[] | String;
  epic_color_not_in?: String[] | String;
  epic_color_lt?: String;
  epic_color_lte?: String;
  epic_color_gt?: String;
  epic_color_gte?: String;
  epic_color_contains?: String;
  epic_color_not_contains?: String;
  epic_color_starts_with?: String;
  epic_color_not_starts_with?: String;
  epic_color_ends_with?: String;
  epic_color_not_ends_with?: String;
  epic_name?: String;
  epic_name_not?: String;
  epic_name_in?: String[] | String;
  epic_name_not_in?: String[] | String;
  epic_name_lt?: String;
  epic_name_lte?: String;
  epic_name_gt?: String;
  epic_name_gte?: String;
  epic_name_contains?: String;
  epic_name_not_contains?: String;
  epic_name_starts_with?: String;
  epic_name_not_starts_with?: String;
  epic_name_ends_with?: String;
  epic_name_not_ends_with?: String;
  project?: String;
  project_not?: String;
  project_in?: String[] | String;
  project_not_in?: String[] | String;
  project_lt?: String;
  project_lte?: String;
  project_gt?: String;
  project_gte?: String;
  project_contains?: String;
  project_not_contains?: String;
  project_starts_with?: String;
  project_not_starts_with?: String;
  project_ends_with?: String;
  project_not_ends_with?: String;
  issuetype_name?: String;
  issuetype_name_not?: String;
  issuetype_name_in?: String[] | String;
  issuetype_name_not_in?: String[] | String;
  issuetype_name_lt?: String;
  issuetype_name_lte?: String;
  issuetype_name_gt?: String;
  issuetype_name_gte?: String;
  issuetype_name_contains?: String;
  issuetype_name_not_contains?: String;
  issuetype_name_starts_with?: String;
  issuetype_name_not_starts_with?: String;
  issuetype_name_ends_with?: String;
  issuetype_name_not_ends_with?: String;
  issuetype_url?: String;
  issuetype_url_not?: String;
  issuetype_url_in?: String[] | String;
  issuetype_url_not_in?: String[] | String;
  issuetype_url_lt?: String;
  issuetype_url_lte?: String;
  issuetype_url_gt?: String;
  issuetype_url_gte?: String;
  issuetype_url_contains?: String;
  issuetype_url_not_contains?: String;
  issuetype_url_starts_with?: String;
  issuetype_url_not_starts_with?: String;
  issuetype_url_ends_with?: String;
  issuetype_url_not_ends_with?: String;
  AND?: jiraIssueWhereInput[] | jiraIssueWhereInput;
  OR?: jiraIssueWhereInput[] | jiraIssueWhereInput;
  NOT?: jiraIssueWhereInput[] | jiraIssueWhereInput;
}

export type jiraIssueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface authorCreateInput {
  name: String;
  slug?: String;
  email?: String;
  bio?: String;
  website?: String;
  location?: String;
  facebook?: String;
  twitter?: String;
  title?: String;
  linkedin?: String;
  vimeo?: String;
  quora?: String;
  medium?: String;
  github?: String;
  meetup?: String;
  pocket?: String;
}

export type epicMetaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface epicMetaUpdateManyMutationInput {
  color?: String;
  name?: String;
}

export interface jiraIssueUpdateInput {
  key?: String;
  assignee_name?: String;
  assignee_url?: String;
  summary?: String;
  status?: String;
  priority_name?: String;
  priority_url?: String;
  priority_rank?: Int;
  updated?: DateTimeInput;
  epic_color?: String;
  epic_name?: String;
  project?: String;
  issuetype_name?: String;
  issuetype_url?: String;
}

export interface authorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: authorWhereInput;
  AND?: authorSubscriptionWhereInput[] | authorSubscriptionWhereInput;
  OR?: authorSubscriptionWhereInput[] | authorSubscriptionWhereInput;
  NOT?: authorSubscriptionWhereInput[] | authorSubscriptionWhereInput;
}

export interface epicMetaCreateInput {
  color: String;
  name: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface jiraIssueConnection {
  pageInfo: PageInfo;
  edges: jiraIssueEdge[];
}

export interface jiraIssueConnectionPromise
  extends Promise<jiraIssueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<jiraIssueEdge>>() => T;
  aggregate: <T = AggregatejiraIssuePromise>() => T;
}

export interface jiraIssueConnectionSubscription
  extends Promise<AsyncIterator<jiraIssueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<jiraIssueEdgeSubscription>>>() => T;
  aggregate: <T = AggregatejiraIssueSubscription>() => T;
}

export interface Aggregateauthor {
  count: Int;
}

export interface AggregateauthorPromise
  extends Promise<Aggregateauthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateauthorSubscription
  extends Promise<AsyncIterator<Aggregateauthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface epicMetaSubscriptionPayload {
  mutation: MutationType;
  node: epicMeta;
  updatedFields: String[];
  previousValues: epicMetaPreviousValues;
}

export interface epicMetaSubscriptionPayloadPromise
  extends Promise<epicMetaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = epicMetaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = epicMetaPreviousValuesPromise>() => T;
}

export interface epicMetaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<epicMetaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = epicMetaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = epicMetaPreviousValuesSubscription>() => T;
}

export interface authorEdge {
  node: author;
  cursor: String;
}

export interface authorEdgePromise extends Promise<authorEdge>, Fragmentable {
  node: <T = authorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface authorEdgeSubscription
  extends Promise<AsyncIterator<authorEdge>>,
    Fragmentable {
  node: <T = authorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface jiraIssuePreviousValues {
  id: ID_Output;
  key: String;
  assignee_name?: String;
  assignee_url?: String;
  summary?: String;
  status: String;
  priority_name?: String;
  priority_url?: String;
  priority_rank?: Int;
  updated?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  epic_color?: String;
  epic_name?: String;
  project: String;
  issuetype_name?: String;
  issuetype_url?: String;
}

export interface jiraIssuePreviousValuesPromise
  extends Promise<jiraIssuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  assignee_name: () => Promise<String>;
  assignee_url: () => Promise<String>;
  summary: () => Promise<String>;
  status: () => Promise<String>;
  priority_name: () => Promise<String>;
  priority_url: () => Promise<String>;
  priority_rank: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  epic_color: () => Promise<String>;
  epic_name: () => Promise<String>;
  project: () => Promise<String>;
  issuetype_name: () => Promise<String>;
  issuetype_url: () => Promise<String>;
}

export interface jiraIssuePreviousValuesSubscription
  extends Promise<AsyncIterator<jiraIssuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  assignee_name: () => Promise<AsyncIterator<String>>;
  assignee_url: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  priority_name: () => Promise<AsyncIterator<String>>;
  priority_url: () => Promise<AsyncIterator<String>>;
  priority_rank: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  epic_color: () => Promise<AsyncIterator<String>>;
  epic_name: () => Promise<AsyncIterator<String>>;
  project: () => Promise<AsyncIterator<String>>;
  issuetype_name: () => Promise<AsyncIterator<String>>;
  issuetype_url: () => Promise<AsyncIterator<String>>;
}

export interface jiraIssueEdge {
  node: jiraIssue;
  cursor: String;
}

export interface jiraIssueEdgePromise
  extends Promise<jiraIssueEdge>,
    Fragmentable {
  node: <T = jiraIssuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface jiraIssueEdgeSubscription
  extends Promise<AsyncIterator<jiraIssueEdge>>,
    Fragmentable {
  node: <T = jiraIssueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface jiraIssue {
  id: ID_Output;
  key: String;
  assignee_name?: String;
  assignee_url?: String;
  summary?: String;
  status: String;
  priority_name?: String;
  priority_url?: String;
  priority_rank?: Int;
  updated?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  epic_color?: String;
  epic_name?: String;
  project: String;
  issuetype_name?: String;
  issuetype_url?: String;
}

export interface jiraIssuePromise extends Promise<jiraIssue>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  assignee_name: () => Promise<String>;
  assignee_url: () => Promise<String>;
  summary: () => Promise<String>;
  status: () => Promise<String>;
  priority_name: () => Promise<String>;
  priority_url: () => Promise<String>;
  priority_rank: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  epic_color: () => Promise<String>;
  epic_name: () => Promise<String>;
  project: () => Promise<String>;
  issuetype_name: () => Promise<String>;
  issuetype_url: () => Promise<String>;
}

export interface jiraIssueSubscription
  extends Promise<AsyncIterator<jiraIssue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  assignee_name: () => Promise<AsyncIterator<String>>;
  assignee_url: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  priority_name: () => Promise<AsyncIterator<String>>;
  priority_url: () => Promise<AsyncIterator<String>>;
  priority_rank: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  epic_color: () => Promise<AsyncIterator<String>>;
  epic_name: () => Promise<AsyncIterator<String>>;
  project: () => Promise<AsyncIterator<String>>;
  issuetype_name: () => Promise<AsyncIterator<String>>;
  issuetype_url: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface epicMetaEdge {
  node: epicMeta;
  cursor: String;
}

export interface epicMetaEdgePromise
  extends Promise<epicMetaEdge>,
    Fragmentable {
  node: <T = epicMetaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface epicMetaEdgeSubscription
  extends Promise<AsyncIterator<epicMetaEdge>>,
    Fragmentable {
  node: <T = epicMetaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface authorConnection {
  pageInfo: PageInfo;
  edges: authorEdge[];
}

export interface authorConnectionPromise
  extends Promise<authorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<authorEdge>>() => T;
  aggregate: <T = AggregateauthorPromise>() => T;
}

export interface authorConnectionSubscription
  extends Promise<AsyncIterator<authorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<authorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateauthorSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface epicMeta {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  color: String;
  name: String;
}

export interface epicMetaPromise extends Promise<epicMeta>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  color: () => Promise<String>;
  name: () => Promise<String>;
}

export interface epicMetaSubscription
  extends Promise<AsyncIterator<epicMeta>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  color: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface authorPreviousValues {
  id: ID_Output;
  name: String;
  slug?: String;
  email?: String;
  bio?: String;
  website?: String;
  location?: String;
  facebook?: String;
  twitter?: String;
  title?: String;
  linkedin?: String;
  vimeo?: String;
  quora?: String;
  medium?: String;
  github?: String;
  meetup?: String;
  pocket?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface authorPreviousValuesPromise
  extends Promise<authorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  email: () => Promise<String>;
  bio: () => Promise<String>;
  website: () => Promise<String>;
  location: () => Promise<String>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  title: () => Promise<String>;
  linkedin: () => Promise<String>;
  vimeo: () => Promise<String>;
  quora: () => Promise<String>;
  medium: () => Promise<String>;
  github: () => Promise<String>;
  meetup: () => Promise<String>;
  pocket: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface authorPreviousValuesSubscription
  extends Promise<AsyncIterator<authorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  linkedin: () => Promise<AsyncIterator<String>>;
  vimeo: () => Promise<AsyncIterator<String>>;
  quora: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  github: () => Promise<AsyncIterator<String>>;
  meetup: () => Promise<AsyncIterator<String>>;
  pocket: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface authorSubscriptionPayload {
  mutation: MutationType;
  node: author;
  updatedFields: String[];
  previousValues: authorPreviousValues;
}

export interface authorSubscriptionPayloadPromise
  extends Promise<authorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = authorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = authorPreviousValuesPromise>() => T;
}

export interface authorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<authorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = authorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = authorPreviousValuesSubscription>() => T;
}

export interface epicMetaPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  color: String;
  name: String;
}

export interface epicMetaPreviousValuesPromise
  extends Promise<epicMetaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  color: () => Promise<String>;
  name: () => Promise<String>;
}

export interface epicMetaPreviousValuesSubscription
  extends Promise<AsyncIterator<epicMetaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  color: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface author {
  id: ID_Output;
  name: String;
  slug?: String;
  email?: String;
  bio?: String;
  website?: String;
  location?: String;
  facebook?: String;
  twitter?: String;
  title?: String;
  linkedin?: String;
  vimeo?: String;
  quora?: String;
  medium?: String;
  github?: String;
  meetup?: String;
  pocket?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface authorPromise extends Promise<author>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  email: () => Promise<String>;
  bio: () => Promise<String>;
  website: () => Promise<String>;
  location: () => Promise<String>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  title: () => Promise<String>;
  linkedin: () => Promise<String>;
  vimeo: () => Promise<String>;
  quora: () => Promise<String>;
  medium: () => Promise<String>;
  github: () => Promise<String>;
  meetup: () => Promise<String>;
  pocket: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface authorSubscription
  extends Promise<AsyncIterator<author>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  linkedin: () => Promise<AsyncIterator<String>>;
  vimeo: () => Promise<AsyncIterator<String>>;
  quora: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  github: () => Promise<AsyncIterator<String>>;
  meetup: () => Promise<AsyncIterator<String>>;
  pocket: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatejiraIssue {
  count: Int;
}

export interface AggregatejiraIssuePromise
  extends Promise<AggregatejiraIssue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatejiraIssueSubscription
  extends Promise<AsyncIterator<AggregatejiraIssue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface jiraIssueSubscriptionPayload {
  mutation: MutationType;
  node: jiraIssue;
  updatedFields: String[];
  previousValues: jiraIssuePreviousValues;
}

export interface jiraIssueSubscriptionPayloadPromise
  extends Promise<jiraIssueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = jiraIssuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = jiraIssuePreviousValuesPromise>() => T;
}

export interface jiraIssueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<jiraIssueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = jiraIssueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = jiraIssuePreviousValuesSubscription>() => T;
}

export interface epicMetaConnection {
  pageInfo: PageInfo;
  edges: epicMetaEdge[];
}

export interface epicMetaConnectionPromise
  extends Promise<epicMetaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<epicMetaEdge>>() => T;
  aggregate: <T = AggregateepicMetaPromise>() => T;
}

export interface epicMetaConnectionSubscription
  extends Promise<AsyncIterator<epicMetaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<epicMetaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateepicMetaSubscription>() => T;
}

export interface AggregateepicMeta {
  count: Int;
}

export interface AggregateepicMetaPromise
  extends Promise<AggregateepicMeta>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateepicMetaSubscription
  extends Promise<AsyncIterator<AggregateepicMeta>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "epicMeta",
    embedded: false
  },
  {
    name: "author",
    embedded: false
  },
  {
    name: "jiraIssue",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466/hackers-graphql/prod`,
  secret: `${process.env["SECRET"]}`
});
export const prisma = new Prisma();
